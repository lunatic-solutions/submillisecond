//! Submillisecond is a [lunatic](https://lunatic.solutions/) web framework.
//!
//! # Usage
//!
//! First, add `submillisecond` as a dependency in `Cargo.toml`:
//!
//! ```toml
//! [dependencies]
//! Submillisecond = "0.1"
//! ```
//!
//! Then, add a `.cargo/config.toml` to configure the target and runner:
//!
//! ```toml
//! [build]
//! target = "wasm32-wasi"
//!
//! [target.wasm32-wasi]
//! runner = "lunatic"
//! ```
//!
//! Finally, define a [handler](crate::Handler) and
//! [router](crate::router), and run your application:
//!
//! ```
//! use submillisecond::{router, Application};
//!
//! fn index() -> &'static str {
//!     "Hello from Submillisecond!"
//! }
//!
//! fn main() -> std::io::Result<()> {
//!     Application::new(router! {
//!         GET "/" => index
//!     })
//!     .serve("0.0.0.0:3000")
//! }
//! ```
//!
//! The submillisecond repository has some more [examples](https://github.com/lunatic-solutions/submillisecond/tree/main/examples) to help you get started.
//!
//! # High-level features
//!
//! Submillisecond has some notable features including:
//!
//! - [Router macro](crate::router) for performant router generated at
//!   compile-time.
//! - [Handlers](crate::Handler): functions taking any number of extractors and
//!   returning any type that implements
//!   [IntoResponse](crate::response::IntoResponse).
//! - [Extractors](crate::extract::FromRequest): types that parse the request to
//!   provide useful data.
//! - Middleware: any handler which calls
//!   [`req.next_handler()`](crate::RequestContext::next_handler).
//! - [Guards](crate::Guard): types that protect routes per request.

#![warn(missing_docs)]
#![cfg_attr(docsrs, feature(doc_cfg, doc_auto_cfg))]

use std::{io, mem};

use http::{header, HeaderValue};
use lunatic::net::{TcpListener, TcpStream, ToSocketAddrs};
use lunatic::{Mailbox, Process};
#[cfg(feature = "logging")]
use lunatic_log::{
    LevelFilter, __lookup_logging_process, error, info, subscriber::fmt::FmtSubscriber,
};
pub use submillisecond_macros::*;
pub use {headers, http};

pub use crate::error::*;
pub use crate::guard::*;
pub use crate::handler::*;
#[cfg(feature = "json")]
pub use crate::json::*;
pub use crate::request::*;
use crate::response::{IntoResponse, Response};
pub use crate::typed_header::*;

#[macro_use]
pub(crate) mod macros;

#[cfg(feature = "cookie")]
pub mod cookies;
mod core;
pub mod defaults;
pub mod extract;
#[cfg(feature = "json")]
mod json;
pub mod params;
pub mod reader;
pub mod response;
#[cfg(feature = "cookie")]
pub mod session;
#[cfg(feature = "template")]
pub mod template;

mod error;
mod guard;
mod handler;
mod request;
mod typed_header;

/// Signature of router function generated by the [`router!`] macro.
pub type Router = fn(RequestContext) -> Response;

/// An application containing a router for listening and handling incoming
/// requests.
///
/// # Example
///
/// ```
/// use submillisecond::{router, Application};
///
/// fn index() -> &'static str { "Welcome" }
///
/// Application::new(router! {
///     GET "/" => index
/// })
/// .serve("0.0.0.0:3000")
/// ```
#[derive(Clone, Copy)]
pub struct Application {
    router: Router,
}

impl Application {
    /// Creates a new application with a given router.
    pub fn new(router: Router) -> Self {
        Application { router }
    }

    /// Listen on `addr` to receive incoming requests, and handling them with
    /// the router.
    pub fn serve<A: ToSocketAddrs + Clone>(self, addr: A) -> io::Result<()> {
        #[cfg(feature = "logging")]
        if __lookup_logging_process().is_none() {
            lunatic_log::init(
                FmtSubscriber::new(LevelFilter::Trace)
                    .with_color(true)
                    .with_level(true)
                    .with_target(true),
            );
        }

        #[cfg(not(feature = "logging"))]
        let listener = TcpListener::bind(addr)?;
        #[cfg(feature = "logging")]
        let listener = TcpListener::bind(addr.clone())?;

        #[cfg(feature = "logging")]
        {
            let addrs = addr
                .to_socket_addrs()?
                .map(|addr| {
                    let ip = addr.ip();
                    let ip_string = if ip.is_unspecified() {
                        "localhost".to_string()
                    } else {
                        ip.to_string()
                    };
                    ansi_term::Style::new()
                        .bold()
                        .paint(format!("http://{}:{}", ip_string, addr.port()))
                        .to_string()
                })
                .collect::<Vec<_>>()
                .join(", ");
            info!("Server started on {addrs}");
        }

        while let Ok((stream, _)) = listener.accept() {
            Process::spawn_link(
                (stream, self.router as *const () as usize),
                |(stream, handler_raw): (TcpStream, usize), _: Mailbox<()>| {
                    let handler = unsafe {
                        let pointer = handler_raw as *const ();
                        mem::transmute::<*const (), Router>(pointer)
                    };

                    let request = match core::parse_request(stream.clone()) {
                        Ok(request) => request,
                        Err(err) => {
                            #[allow(unused_variables)]
                            if let Err(err) = core::write_response(stream, err.into_response()) {
                                #[cfg(feature = "logging")]
                                error!("[http reader] Failed to send response {:?}", err);
                            }
                            return;
                        }
                    };

                    #[cfg(feature = "logging")]
                    {
                        let method_string = match *request.method() {
                            http::Method::GET => ansi_term::Color::Green.normal(),
                            http::Method::POST => ansi_term::Color::Blue.normal(),
                            http::Method::PUT => ansi_term::Color::Yellow.normal(),
                            http::Method::DELETE => ansi_term::Color::Red.normal(),
                            http::Method::HEAD => ansi_term::Color::Purple.normal(),
                            http::Method::OPTIONS => ansi_term::Color::Blue.dimmed(),
                            http::Method::PATCH => ansi_term::Color::Cyan.normal(),
                            _ => ansi_term::Color::White.normal(),
                        }
                        .bold()
                        .paint(request.method().as_str());

                        let ip = ansi_term::Style::new().dimmed().paint(
                            request
                                .headers()
                                .get(http::header::HeaderName::from_static("x-forwarded-for"))
                                .and_then(|v| v.to_str().ok())
                                .unwrap_or("-"),
                        );

                        info!("{} {}    {}", method_string, request.uri(), ip);
                    }

                    let http_version = request.version();

                    let mut response =
                        Handler::handle(&handler, RequestContext::from(request)).into_response();

                    let content_length = response.body().len();
                    *response.version_mut() = http_version;
                    response
                        .headers_mut()
                        .append(header::CONTENT_LENGTH, HeaderValue::from(content_length));

                    #[allow(unused_variables)]
                    if let Err(err) = core::write_response(stream, response) {
                        #[cfg(feature = "logging")]
                        error!("[http reader] Failed to send response {:?}", err);
                    }
                },
            );
        }

        Ok(())
    }
}
